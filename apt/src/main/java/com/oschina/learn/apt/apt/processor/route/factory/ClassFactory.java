package com.oschina.learn.apt.apt.processor.route.factory;

import com.oschina.learn.apt.apt.processor.route.model.Constants;
import com.oschina.learn.apt.apt.processor.route.model.FieldData;
import com.oschina.learn.apt.apt.processor.route.util.UtilMgr;
import com.oschina.learn.apt.apt.processor.route.util.Utils;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.List;

import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;

/**
 * Created by admin on 16/10/14.
 */

public class ClassFactory {

    List<FieldData> list;
    TypeElement type;

    public ClassFactory (List<FieldData> list, TypeElement type) {
        this.list = list;
        this.type = type;
    }

    public void generateCode () throws IOException {
        // create package and class name of generating class
        String packName = Utils.getPackageName(type);
        String clzName = type.getQualifiedName().toString();
        clzName = Utils.isEmpty(packName) ? clzName + Constants.INJECTOR_SUFFIX
                : clzName.substring(packName.length() + 1).replace(".","$") + Constants.INJECTOR_SUFFIX;

        TypeElement injector = getClassByName(Constants.INJECTOR_INTERFACE);
        ClassName className = ClassName.get(injector);
        TypeName typeName = ParameterizedTypeName.get(className, TypeName.get(type.asType()));
        TypeSpec.Builder classBuidler = TypeSpec.classBuilder(clzName)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(typeName);

        MethodSpec.Builder injectToTarget = MethodSpec.methodBuilder(Constants.INJECTOR_METHOD_TO_DATA)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.VOID)
                .addParameter(ParameterSpec.builder(TypeName.get(type.asType()), "target").build())
                .addParameter(ParameterSpec.builder(getTypeNameByName(Constants.CLASS_NAME_BUNDLE), "data").build())
                .addStatement("Object obj = null");

        MethodSpec.Builder injectToBundle = MethodSpec.methodBuilder(Constants.INJECTOR_METHOD_TO_BUNDLE)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.VOID)
                .addParameter(ParameterSpec.builder(TypeName.get(type.asType()), "target").build())
                .addParameter(ParameterSpec.builder(getTypeNameByName(Constants.CLASS_NAME_BUNDLE), "data").build());

        for (FieldData fieldData : list) {
            completeInjectToTarget(injectToTarget,fieldData);
            completeInjectToBundle(injectToBundle,fieldData);
        }
        classBuidler.addMethod(injectToTarget.build());
        classBuidler.addMethod(injectToBundle.build());
        JavaFile.Builder builder = JavaFile.builder(packName, classBuidler.build());
        builder.addFileComment("The class is generated by Parceler,do not modify!");
        JavaFile build = builder.build();

        build.writeTo(UtilMgr.getMgr().getFiler());
    }

    private void completeInjectToBundle(MethodSpec.Builder injectToBundle, FieldData fieldData) {
        TypeName fieldType = TypeName.get(fieldData.getVar().asType());
        String fieldName = fieldData.getVar().getSimpleName().toString();
        boolean unBoxType = isUnBoxType(fieldType);
        if (!unBoxType) {
            if (fieldData.isPrivate()) {
                injectToBundle.beginControlFlow("if (target.$N() != null)",Utils.combineGetMethodName(fieldName))
                        .addStatement("data.$N($S,target.$N())",fieldData.getMethodName(),fieldData.getKey(),Utils.combineGetMethodName(fieldName))
                        .endControlFlow();
            } else {
                injectToBundle.beginControlFlow("if (target.$N != null)",fieldName)
                        .addStatement("data.$N($S,target.$N)",fieldData.getMethodName(),fieldData.getKey(),fieldName)
                        .endControlFlow();
            }
        } else {
            if (fieldData.isPrivate()) {
                injectToBundle.addStatement("data.$N($S,target.$N())",fieldData.getMethodName(),fieldData.getKey(),Utils.combineGetMethodName(fieldName));
            } else {
                injectToBundle.addStatement("data.$N($S,target.$N)",fieldData.getMethodName(),fieldData.getKey(),fieldName);
            }
        }
    }

    private void completeInjectToTarget(MethodSpec.Builder injectToData, FieldData fieldData) {
        TypeName fieldType = TypeName.get(fieldData.getVar().asType());
        String fieldName = fieldData.getVar().getSimpleName().toString();

        if (isUnBoxType(fieldType)) {
            injectToData.beginControlFlow("if (data.get($S) != null)",fieldData.getKey());
        } else {
            injectToData.beginControlFlow("if ((obj = data.get($S)) != null && obj instanceof $N)",fieldData.getKey(),fieldData.getCastName());
        }

        if (fieldData.isPrivate()) {
            injectToData.addStatement("target.$N(($T)data.get($S))",Utils.combineSetMethodName(fieldName),fieldData.getVar(),fieldData.getKey());
        } else {
            injectToData.addStatement("target.$N = ($T)data.get($S)",fieldData.getVar().getSimpleName(),fieldData.getVar(),fieldData.getKey());
        }
        injectToData.endControlFlow();
        if (fieldData.isNonNull()) {
            injectToData.beginControlFlow("else")
                    .addStatement("throw new $T(\"Field $N in $N has requires non-null\")",IllegalArgumentException.class,fieldData.getVar().getSimpleName(),type.getSimpleName())
                    .endControlFlow();
        }

    }

    TypeElement getClassByName (String clzName) {
        return UtilMgr.getMgr().getElementUtils().getTypeElement(clzName);
    }

    TypeName getTypeNameByName (String clzName) {
        return TypeName.get(getClassByName(clzName).asType());
    }

    TypeName unBoxTypeName (TypeName name) {
        if (name.isBoxedPrimitive()) {
            return name.unbox();
        }
        return name;
    }

    boolean isUnBoxType(TypeName name) {
        switch (name.toString()) {
            case "boolean":
            case "byte":
            case "char":
            case "short":
            case "int":
            case "long":
            case "float":
            case "double":
                return true;
        }
        return false;
    }
}
